import { Context } from 'probot';
import { PullRequestEvent } from '@octokit/webhooks-types';
import { logger } from '../config/logger';

export interface CopilotSignal {
  type: 'commit_metadata' | 'velocity' | 'comment_pattern' | 'boilerplate' | 'file_creation';
  confidence: number;
  evidence: string;
}

export interface FileAnalysis {
  filename: string;
  probability: number;
  signals: CopilotSignal[];
}

export interface CopilotAnalysis {
  overallProbability: number;
  confidence: 'high' | 'medium' | 'low' | 'none';
  fileAnalyses: Map<string, FileAnalysis>;
  reasoning: string;
}

export class CopilotDetector {
  private readonly COPILOT_INDICATORS = [
    'GitHub Copilot',
    'Co-authored-by: GitHub Copilot',
    'github-copilot',
  ];

  private readonly AI_COMMENT_PATTERNS = [
    /\/\/ (TODO|FIXME|NOTE): .{50,}/,
    /\/\* \*\//,  // JSDoc style
    /""".+"""$/ms,  // Python docstrings
    /\/\*\*[\s\S]*?\*\//,  // Multi-line JSDoc
  ];

  /**
   * Analyze PR to detect if code was generated by GitHub Copilot
   */
  async analyze(
    context: Context<'pull_request'>,
    pr: PullRequestEvent['pull_request']
  ): Promise<CopilotAnalysis> {
    const signals: CopilotSignal[] = [];
    const fileAnalyses = new Map<string, FileAnalysis>();

    try {
      // Get PR commits
      const commits = await context.octokit.pulls.listCommits({
        owner: context.payload.repository.owner.login,
        repo: context.payload.repository.name,
        pull_number: pr.number,
      });

      // Get PR files
      const files = await context.octokit.pulls.listFiles({
        owner: context.payload.repository.owner.login,
        repo: context.payload.repository.name,
        pull_number: pr.number,
      });

      // Signal 1: Check commit messages for Copilot metadata
      for (const commit of commits.data) {
        if (this.hasCommitCopilotSignal(commit.commit.message)) {
          signals.push({
            type: 'commit_metadata',
            confidence: 0.95,
            evidence: `Commit "${commit.commit.message.substring(0, 50)}..." explicitly mentions Copilot`,
          });
        }
      }

      // Signal 2: Analyze each file
      for (const file of files.data) {
        const fileSignals = await this.analyzeFile(file);
        
        if (fileSignals.length > 0) {
          const fileProbability = this.calculateProbability(fileSignals);
          fileAnalyses.set(file.filename, {
            filename: file.filename,
            probability: fileProbability,
            signals: fileSignals,
          });
          signals.push(...fileSignals);
        }
      }

      // Calculate overall probability
      const overallProbability = this.calculateProbability(signals);
      const confidence = this.determineConfidence(overallProbability, signals.length);
      const reasoning = this.generateReasoning(signals, overallProbability);

      logger.info('Copilot detection completed', {
        pr: pr.number,
        probability: overallProbability,
        confidence,
        signals: signals.length,
      });

      return {
        overallProbability,
        confidence,
        fileAnalyses,
        reasoning,
      };
    } catch (error) {
      logger.error('Copilot detection failed', { error, pr: pr.number });
      return {
        overallProbability: 0,
        confidence: 'none',
        fileAnalyses: new Map(),
        reasoning: 'Detection failed',
      };
    }
  }

  /**
   * Analyze individual file for Copilot signals
   */
  private async analyzeFile(file: any): Promise<CopilotSignal[]> {
    const signals: CopilotSignal[] = [];

    if (!file.patch) return signals;

    // Signal: High velocity (large additions)
    if (file.additions > 50 && file.additions > file.deletions * 3) {
      signals.push({
        type: 'velocity',
        confidence: Math.min(0.7, file.additions / 100),
        evidence: `Large code addition: ${file.additions} lines added`,
      });
    }

    // Signal: New file creation with substantial code
    if (file.status === 'added' && file.additions > 30) {
      signals.push({
        type: 'file_creation',
        confidence: 0.6,
        evidence: `New file created with ${file.additions} lines`,
      });
    }

    // Signal: AI-typical comment patterns
    const aiCommentMatches = this.findAICommentPatterns(file.patch);
    if (aiCommentMatches.length > 0) {
      signals.push({
        type: 'comment_pattern',
        confidence: 0.5,
        evidence: `Found ${aiCommentMatches.length} AI-typical comment patterns`,
      });
    }

    // Signal: Boilerplate code patterns
    if (this.hasBoilerplatePatterns(file.patch, file.filename)) {
      signals.push({
        type: 'boilerplate',
        confidence: 0.4,
        evidence: 'Contains typical boilerplate code structure',
      });
    }

    return signals;
  }

  /**
   * Check commit message for Copilot indicators
   */
  private hasCommitCopilotSignal(message: string): boolean {
    return this.COPILOT_INDICATORS.some(indicator =>
      message.toLowerCase().includes(indicator.toLowerCase())
    );
  }

  /**
   * Find AI-typical comment patterns
   */
  private findAICommentPatterns(patch: string): RegExpMatchArray[] {
    const matches: RegExpMatchArray[] = [];
    
    for (const pattern of this.AI_COMMENT_PATTERNS) {
      const match = patch.match(pattern);
      if (match) {
        matches.push(match);
      }
    }

    return matches;
  }

  /**
   * Detect boilerplate code patterns
   */
  private hasBoilerplatePatterns(patch: string, filename: string): boolean {
    const addedLines = patch.split('\n').filter(line => line.startsWith('+'));
    
    // Check for common boilerplate structures
    const boilerplateKeywords = [
      'constructor',
      'interface',
      'export class',
      'export interface',
      'export type',
      'import {',
      'from \'',
      'async function',
      'export default',
    ];

    const keywordCount = boilerplateKeywords.filter(keyword =>
      addedLines.some(line => line.includes(keyword))
    ).length;

    // If multiple boilerplate keywords found, likely AI-generated
    return keywordCount >= 3;
  }

  /**
   * Calculate probability from signals
   */
  private calculateProbability(signals: CopilotSignal[]): number {
    if (signals.length === 0) return 0;

    // Weighted average with diminishing returns
    const weights = signals.map((s, idx) => s.confidence * (1 - idx * 0.1));
    const totalWeight = weights.reduce((sum, w) => sum + w, 0);
    const avgConfidence = totalWeight / signals.length;

    // Cap at 0.95 (never 100% certain)
    return Math.min(0.95, avgConfidence);
  }

  /**
   * Determine confidence level
   */
  private determineConfidence(
    probability: number,
    signalCount: number
  ): 'high' | 'medium' | 'low' | 'none' {
    if (probability >= 0.8 && signalCount >= 3) return 'high';
    if (probability >= 0.6 && signalCount >= 2) return 'medium';
    if (probability >= 0.3) return 'low';
    return 'none';
  }

  /**
   * Generate human-readable reasoning
   */
  private generateReasoning(signals: CopilotSignal[], probability: number): string {
    if (signals.length === 0) {
      return 'No Copilot indicators detected';
    }

    const signalDescriptions = signals
      .slice(0, 3)  // Top 3 signals
      .map(s => `- ${s.evidence} (confidence: ${(s.confidence * 100).toFixed(0)}%)`)
      .join('\n');

    return `Copilot detection probability: ${(probability * 100).toFixed(0)}%\n\nKey indicators:\n${signalDescriptions}`;
  }
}
